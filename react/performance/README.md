## React.memo를 활용하여 리렌더링 되는 부분을 최소화하여 렌더링 속도 향상

### React는 먼저 컴포넌트를 렌더링(rendering) 한 뒤, 이전에 렌더링 된 결과와 비교하여 DOM 업데이트를 결정. 만약 렌더링 결과가 이전과 다르다면 React는 DOM을 업데이트함, 이 과정에서 만약 컴포넌트가 React.memo()로 둘러쌓여 있다면 React는 컴포넌트를 렌더링하고 결과를 메모이징함 그리고 다음 렌더링이 일어날때 렌더링하는 컴포넌트의 props가 같다면, React는 메모이징된 내용을 재사용

처음 렌더링 할 때 결과를 메모이징 함, 그리고 다음 렌더링 시 props가 같기 때문에 메모이징 된 내용을 재 사용

### React.memo를 지양해야할때

렌더링 될 때 props가 다른 경우가 대부분인 컴포넌트를 생각해보면, 메모이제이션 기법의 이점을 얻기 힘듦.<br/>
props가 자주 변하는 컴포넌트를 React.memo()로 래핑 할지라도, React는 두 가지 작업을 리 렌더링 할 때마다 수행함

-> React.memo는 리렌더링을 막기 위한 도구보다는 성능 개선의 도구<br/>
-> 프로파일러를 사용해서 성능이 개선되는지 확인하고 사용

## 얕은비교 Shallow Compare

숫자, 문자열 등 원시 자료형은 값을 비교함
배열, 객체 등 참조 자료형은 값 혹은 속성을 비교하지 않고, 참조되는 위치를 비교

const obj1 = { a: 1, b: 2 }; <br/>
const obj1 = { a: 1, b: 2 }; <br/>
console.log(obj1 === obj2); //false

### 깊은 비교란 ?

얕은 비료와 달리 깊은 비교는 객체의 경우에도 값으로 비교 <br/>

- Object depth가 깊지 않은 경우 : JSON.stringify()사용
- Object depth가 깊은 경우 : lodash 라이브러리의 isEqual()사용

### 얕은 비교를 사용하는 경우

1. React.memo()에서 props를 비교할 때
1. 리액트 컴포넌트가 리 렌더링을 하기 전
   1. state 변경이 있을 때
   1. 부모 컴포넌트가ㅏ 렌더링 될때

---

> 리액트가 리랜더링 되는 경우
>
> > state 변경이 있을 때<br/>
> > 부모 컴포넌트가 렌더링 될 때<br/>
> > 새로운 props가 들어올 때<br/>
> > shouldComponentUpdate에서 true가 반환될 때<br/>
> > forceUpdate가 실행될 때

## useCallback을 이용하여 함수 최적화

원래 컴포넌트가 렌더링 될 때 그 안에 있는 함수도 다시 만들게 됩니다. 하지만 똑같은 함수를 컴포넌트가 리렌더링 된다고 해서 계속 다시 만드는것은 좋은 현상이 아니다. 그리고 이렇게 컴포넌트가 리렌더링 될 때마다 함수를 계속 다시 만든다고 하면 만약 이 함수가 자식 컴포넌트에 props로 내려 준다면 함수를 포함하고 있는 컴포넌트가 리렌더링 될 때마다 자식 컴포넌트도 함수가 새롭게 만들어지니 계속 리렌더링 하게됨.

-> useCallback 적용으로 문제해결
useCallback 적용은 useCallback 안에 콜백함수와 의존성 배열을 순서대로 넣어주면 됨

const testFunction = useCallback(() ⇒ {}, []);

- 함수 내에서 참조하는 state, props가 있다면 의존성 배열에 추가해주면 됨

- useCallback으로 인해서 의존성 배열에 추가해준 state혹은 props가 변하지 않는 다면 함수는 새로 생성되지 않음

- 새로 생성되지 않기에 메모리에 새로 할당되지 않고 동일 참조 값을 사용하게 됨

- 의존성 배열에 아무것도 없다면 컴포넌트가 최초 렌더링 시에만 함수가 생성되며 그 이후에는 동일한 참조값을 사용하는 함수가 됨

## Memoization 이란 ?

메모이제이션은 비용이 많이 드는 함수 호출의 결과를 저장하고 동일한 입력이 다시 발생할 때 캐시된 결과를 반환하여 컴퓨터 프로그램의 속도를 높이는데 주로 사용되는 최적화 기술

Comonent 내의 compute함수가 만약 복잡한 연산을 수행하면 결과 값을 리턴하는데 오랜 시간이 걸리게됨.<br/>
이럴 시에 컴포넌트가 계속 리렌더링된다면 연산을 계속 수행하는데 오랜 시간이 걸려서 성능에 안좋은 영향을 미치게 되며, UI 지연 현상도 일어나게 됨<br/>

이러한 현상을 해결해주기 위해서 사용하는 것이 useMemo<br/>

compute 함수에 넘겨주는 a, b의 값이 이전과 동일하다면 컴포넌트가 리렌더링 되더라도 연산을 다시 하지 않고 이전 렌더링 때 저장해두었던 값을 재활용하게 됨<br/>

### useMemo 적용하기

useMemo로 감싸준 후에 첫번째 인수에 의존성 배열에 compute 함수에서 사용하는 값을 넣어줌

```function Component({ a, b }) {
	const result = useMemo(() => compute(a, b), [a, b])
	return <div>{result}</div>
}
```
